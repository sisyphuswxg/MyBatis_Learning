<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 当Mapper接口和XML文件关联时，namespace的值就需要配置成接口的全限定名称 -->
<mapper namespace="com.sisyphuswxg.book2.mapper.UserMapper">

    <!--
      resultMap:column和property将查询列的值映射到type对象的属性上
        column:数据库列名；  property：java类属性名;
        关于property：不区分大小写，但方便阅读，尽可能区分一下~
        此外，mybatis还提供了将下划线命名的数据库转换为Java对象的驼峰式命名，如user_name转换为userName，
           若要使用该功能，需要在配置文件的<settings>中将mapUnderscoreToCamelCase属性设置为true（默认为false）
     -->
    <resultMap id="userMap" type="sysUser">
        <id property="id" column="id"/>
        <result property="userName" column="user_name"/>
        <result property="userPassword" column="user_password"/>
        <result property="userEmail" column="user_email"/>
        <result property="userInfo" column="user_info"/>
        <result property="headImg" column="head_img" jdbcType="BLOB"/>
        <result property="createTime" column="create_time" jdbcType="TIMESTAMP"/>
    </resultMap>

    <select id="selectById" resultMap="userMap">
        select *
        from sys_user
        where id = ${id}
    </select>

    <!--
        直接通过resultType来设置返回结果的类型，不过这里要为所有列名和属性名不一致的列设置别名
        通过设置别名使最终的查询结果列和resultType指定对象的属性名保持一致，进而实现自动映射。

        因此：将查询列映射到对象属性就有两种办法：
        1. 通过在resultMap中配置property和column属性的映射，参考selectById
        2. 在SQL中设置别名，参考selectAll
     -->
    <select id="selectAll" resultType="sysUser">
        select id,
               user_name     userName,
               user_password userPassword,
               user_email    userEmail,
               user_info     userInfo,
               head_img      headImg,
               create_time   createTime
        from sys_user
    </select>


    <!--
     根据用户id获取角色信息
       - 根据用户id获取用户拥有的所有角色，返回的结果是角色集合（结果只有角色的信息，不包括额外的其他字段信息）
       - 涉及到3个表：sys_user、sys_role、sys_user_role
    -->
    <select id="selectRolesByUserId" resultType="sysRole">
        select r.id,
               r.role_name   roleName,
               r.enabled,
               r.create_by   createBy,
               r.create_time createTime
        from sys_user u
                 inner join sys_user_role ur on u.id = ur.user_id
                 inner join sys_role r on ur.role_id = r.id
        where u.id = ${id}
    </select>

    <!--
     根据用户id获取角色信息（返回角色信息 + 用户信息）
     是上面例子的进阶版。
     有两种处理办法：
     1. 在SysRole中新增两个属性userName和userEmail。或新建一个SysRoleExtend继承类，在新类中增加属性
        当新增的user属性过多时这种办法就不太使用
     2. 直接在SysRole中新增一个SysUser对象，字段名为user，同时修改如下sql语句：
    -->
    <select id="selectRolesByUserIdPro" resultType="sysRole">
        select r.id,
               r.role_name     roleName,
               r.enabled,
               r.create_by     createBy,
               r.create_time   createTime,
               u.user_name  as "user.userName",
               u.user_email as "user.userEmail"
        from sys_user u
                 inner join sys_user_role ur on u.id = ur.user_id
                 inner join sys_role r on ur.role_id = r.id
        where u.id = ${id}
    </select>


    <!--
    插入一条数据：这里是一个简单的Demo
    如下：为了防止类型错误，对于一些特殊的数据类型，建议指定具体的jdbcType值。
      - 例如headImg指定BLOG类型，BLOG对应的类型是ByteArrayInputStream，即二进制数据流。
      - createTime指定TIMESTAMP类型，因为数据库区分date/time/datetime，但Java中都使用java.util.Date类型，因此需要手动指定。
        date、time、datetime对应的JDBC类型分别是DATE、TIME、TIMESTAMP。
    -->
    <insert id="insertOneUser">
        insert into sys_user(id,
                             user_name,
                             user_password,
                             user_email,
                             user_info,
                             head_img,
                             create_time)
        values (#{id},
                #{userName},
                #{userPassword},
                #{userEmail},
                #{userInfo},
                #{headImg, jdbcType=BLOB},
                #{createTime, jdbcType=TIMESTAMP})
    </insert>


    <!--
    配置了useGeneratedKeys和keyProperty属性。
      useGeneratedKeys设置为true后，MyBatis会使用JDBC的getGeneratedKeys来取出由数据库内部生成的主键。
      获得主键后再赋值给keyProperty配置的id属性。
    存在局限：只适用于支持主键自增的数据库，有些数据库如Oracle是不支持主键自增的，获取id则需要下面一种方法。
    -->
    <insert id="insertOneUser2" useGeneratedKeys="true" keyProperty="id">
        insert into sys_user(user_name,
                             user_password,
                             user_email,
                             user_info,
                             head_img,
                             create_time)
        values (#{userName},
                #{userPassword},
                #{userEmail},
                #{userInfo},
                #{headImg, jdbcType=BLOB},
                #{createTime, jdbcType=TIMESTAMP})
    </insert>

    <!--
      使用<selectKey>标签来获取主键的值。
      keyColumn和keyProperty和上面的useGeneratedKeys的用法含义相同。
      这里的resultType用于设置返回值类型；order属性设置是在insert语句执行前还是执行后获取。
      LAST_INSERT_ID():用于获取数据库中最后插入的数据的ID值。（MySQL使用的）
    -->
    <insert id="insertOneUser3">
        insert into sys_user
        (user_name,
        user_password,
        user_email,
        user_info,
        head_img,
        create_time)
        values
        (#{userName},
        #{userPassword},
        #{userEmail},
        #{userInfo},
        #{headImg, jdbcType=BLOB},
        #{createTime, jdbcType=TIMESTAMP})
        <selectKey keyColumn="id" resultType="long" keyProperty="id" order="AFTER">
            SELECT LAST_INSERT_ID()
        </selectKey>
    </insert>

    <!--
    根据主键（id)更新
    -->
    <update id="updateById">
        update sys_user
        set user_name     = #{userName},
            user_password = #{userPassword},
            user_email    = #{userEmail},
            user_info     = #{userInfo},
            head_img      = #{headImg, jdbcType=BLOB},
            create_time   = #{createTime, jdbcType=TIMESTAMP}
        where id = #{id}
    </update>

    <!--
    根据主键（id)删除
    -->
    <delete id="deleteById">
        delete
        from sys_user
        where id = #{id}
    </delete>

    <!--
      多个参数：不使用@Param时
        注意：where子句中，不能使用#{userId}和#{enabled}，会报错，报错信息是：Parameter 'id' not found. Available parameters are [arg1, arg0, param1, param2]
        而要修改成：#{arg0}、#{arg1}或#{param1}、#{param2}
    -->
    <select id="selectRolesByUserIdAndRoleEnabled01" resultType="sysRole">
        select r.id,
               r.role_name   roleName,
               r.enabled,
               r.create_by   createBy,
               r.create_time createTime
        from sys_user u
                 inner join sys_user_role ur on u.id = ur.user_id
                 inner join sys_role r on ur.role_id = r.id
        where u.id = #{param1}
          and r.enabled = #{param2}
    </select>

    <!--
      多个参数：使用@Param时（在接口文件UserMapper.java文件，定义接口时带上@Param注解）
        注意：此时在SQL语句中，就可以使用@{userId}和@{enabled}。或者可以使用@{param1}和@{param2}
        注意：不能使用@{arg0}和@{arg1}，会报错，报错信息是：Parameter 'arg0' not found. Available parameters are [userId, param1, enabled, param2]

        注意：当参数是JavaBean时，如(@Param("userId") SysUser user, @Param("enabled") SysRole role)，此时可以在xml中使用#{user.id}和#{role.enabled}。
    -->
    <select id="selectRolesByUserIdAndRoleEnabled02" resultType="sysRole">
        select r.id,
               r.role_name   roleName,
               r.enabled,
               r.create_by   createBy,
               r.create_time createTime
        from sys_user u
                 inner join sys_user_role ur on u.id = ur.user_id
                 inner join sys_role r on ur.role_id = r.id
        where u.id = #{userId}
          and r.enabled = #{enabled}
    </select>

    <!--
    MyBatis提供了@Select/@Update/@Insert/@Delete注解的方式，可以直接在接口类上书写sql语句。
      - 不推荐此种使用方式，因为：注解方式需要手动拼接字符串，需要编写代码重新编译，不方便维护，除非在程序简单且数据库表基本不变的情况下，否则都不建议使用。
    -->


    <!--
    动态SQL:
      - MyBatis的强大功能之一
      - 采用了功能强大的OGNL（ObjectGraphNavigationLanguage）表达式语言
      - 常用有如下几个标签:
        - if
        - choose(when、otherwise)
        - trim(where、set)
        - foreach
        - bind
    -->

    <!--
     如下Demo： select语句中的if标签

     如果sql的where子句写法如下：带来的问题就是当只提供userName参数，不提供userEmail时，会导致user_email=null也会成为查询条件，导致查不出正确的结果。
       where user_name like concat('%', #{userName}, '%') and user_email like concat('%', #{userEmail}, '%')
     使用if标签的代码可以解决，如下。
       if标签有一个必填的属性test，test的属性值是一个符合OGNL要求的判断表达式，表达式的结果可以是true或false（非0的值都视为true）
       property != null 或 property == null 用来判断属性值是否为空
       property != '' 或 property == '' 用来判断属性值是否为空字符串
       可以使用and或or，意思同java中的&&和||
     注意：这里多了一个1=1条件，避免当两个条件都不满足时SQL语法错误的情况，后续会使用where标签进行优化。
    -->
    <select id="selectByUser" resultType="sysUser">
        select
        id,
        user_name userName,
        user_password userPassword,
        user_email userEmail,
        user_info userInfo,
        head_img headImg,
        create_time createTime
        from sys_user
        where 1= 1
        <if test="userName != null and userName != ''">
            and user_name like concat('%', #{userName}, '%')
        </if>
        <if test="userEmail!= null and userEmail!= ''">
            and user_email like concat('%', #{userEmail}, '%')
        </if>
    </select>

    <!--
    动态SQL： Update语句中的if标签
    -->
    <update id="updateByIdSelective">
        update sys_user
        set
        <if test="userName != null and userName != ''">
            user_name = #{userName},
        </if>
        <if test="userPassword != null and userPassword != ''">
            user_password= #{userPassword},
        </if>
        <if test="userEmail != null and userEmail != ''">
            user_email = #{userEmail},
        </if>
        <if test="userInfo != null and userInfo != ''">
            user_info = #{userInfo},
        </if>
        <if test="headImg != null">
            head_img = #{headImg, jdbcType=BLOB},
        </if>
        <if test="createTime != null">
            create_time = #{createTime, jdbcType=TIMESTAMP},
        </if>
        id = #{id}
        where id = #{id}
    </update>

    <!--
    动态SQL： Insert语句中的if标签
    -->
    <insert id="insertSelective" useGeneratedKeys="true" keyProperty="id">
        insert into sys_user(user_name,
        user_password,
        <if test="userEmail != null and userEmail != ''">
            user_email,
        </if>
        user_info,
        head_img,
        create_time
        )
        values(
        #{userName},
        #{userPassword},
        <if test="userEmail != null and userEmail != ''">
            #{user_email},
        </if>
        #{userInfo},
        #{headImg, jdbcType=BLOB},
        #{createTime, jdbcType=TIMESTAMP}
        )
    </insert>

    <!--
    choose: 可以实现if...else...的逻辑
    choose标签中至少包含1个when，0个或1个otherwise。
    -->
    <select id="selectByIdOrUserName" resultType="sysUser">
        select id,
        user_name userName,
        user_password userPassword,
        user_info userInfo,
        head_img headImg,
        create_time createTime
        from sys_user
        where 1 = 1
        <choose>
            <when test="id != null">
                and id = #{id}
            </when>
            <when test="userName != null and userName != ''">
                and user_name = #{userName}
            </when>
            <otherwise>
                and 1 = 2
            </otherwise>
        </choose>
    </select>

    <!--
    where标签：
      - 和Select语句的if标签是相同例子，这里使用where语句来优化
      - where标签的作用：
        1. 如果该标签包含的元素有返回值，就插入一个where
        2. 如果where后面的字符串是以AND和OR开头的，就删除掉
      使用where标签后，不需要再像前面的需要写1=1这种语句。
      如下demo，如果if条件满足，where元素的内容就是以and开头的条件，where会自动去掉开头的and；
               如果if条件不满足，where元素中没有内容，SQL中也不会出现where。
    -->
    <select id="selectByUser2" resultType="sysUser">
        select
        id,
        user_name userName,
        user_password userPassword,
        user_email userEmail,
        user_info userInfo,
        head_img headImg,
        create_time createTime
        from sys_user
        <where>
            <if test="userName != null and userName != ''">
                and user_name like concat('%', #{userName}, '%')
            </if>
            <if test="userEmail!= null and userEmail!= ''">
                and user_email like concat('%', #{userEmail}, '%')
            </if>
        </where>
    </select>

    <!--
    set标签：
      - 如果该标签包含的元素中有返回值，就插入一个set；
      - 如果set后面的字符串是以逗号结尾的，就将这个逗号剔除；
    -->
    <update id="updateByIdSelective2">
        update sys_user
        <set>
            <if test="userName != null and userName != ''">
                user_name = #{userName},
            </if>
            <if test="userPassword != null and userPassword != ''">
                user_password= #{userPassword},
            </if>
            <if test="userEmail != null and userEmail != ''">
                user_email = #{userEmail},
            </if>
            <if test="userInfo != null and userInfo != ''">
                user_info = #{userInfo},
            </if>
            <if test="headImg != null">
                head_img = #{headImg, jdbcType=BLOB},
            </if>
            <if test="createTime != null">
                create_time = #{createTime, jdbcType=TIMESTAMP},
            </if>
            id = #{id}
        </set>
        where id = #{id}
    </update>

    <!--
    动态SQL语句：trim标签
      - where标签和set标签都可以通过trim标签来实现，底层都是通过TrimSqlNode实现的；
    -->

    <!--
    foreach:
      01. foreach实现in集合（或数组），是最简单和常用的一种情况
      foreach中的属性：
        - collection：必填，值是要迭代循环的属性名
        - item：变量名，值从迭代对象中取出的每一个值
        - index：索引的属性名，在集合数组情况下值为当前索引值，当迭代循环的对象是Map类型时，这个是为Map的key。
        - open：整个循环内容开头的字符串
        = close：整个循环结尾的字符串
        - separator：每次循环的分隔符
    -->
    <select id="selectByIdList" resultType="sysUser">
        select id,
        user_name userName,
        user_password userPassword,
        user_email userEmail,
        user_info userInfo,
        head_img headImg,
        create_time createTime
        from sys_user
        where id in
        <foreach collection="list" open="(" close=")" separator="," item="id" index="i">
            #{id}
        </foreach>
    </select>

    <!--
    foreach: 实现批量插入
    -->
    <insert id="insertList">
        insert into sys_user(
        user_name,
        user_password,
        user_email,
        user_info,
        head_img,
        create_time)
        values
        <foreach collection="list" item="user" separator=",">
            (#{user.userName},
            #{user.userPassword},
            #{user.userEmail},
            #{user.userInfo},
            #{user.headImg, jdbcType=BLOB},
            #{user.createTime, jdbcType=TIMESTAMP})
        </foreach>
    </insert>

    <!--
    foreach实现动态UPDATE
      - 当参数是Map类型时，foreach标签的index属性值对应的不是索引值，而是Map中的key
      - _parameter：MyBatis内部的上下文使用了默认值_parameter作为该参数的key
    -->
    <update id="updateByMap">
        update sys_user
        set
        <foreach collection="_parameter" item="val" index="key" separator=",">
            ${key} = #{val}
        </foreach>
        where id = #{id}
    </update>


</mapper>